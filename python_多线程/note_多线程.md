# 环境
- windows 10
- anaconda
- pycharm
- python 3.6
- http://www.cnblogs.com/jokerbj/p/7460260.html
- http://www.dabeaz.com/python/UnderstandingGIL.pdf

# 多线程 && 多进程
- 程序：一对代码以文本形式存入一个文档
- 进程：程序运行的一个状态
    - 包含地址空间、内存、数据栈等
    - 每个程序的独立运行就是一个进程
    - 每个进程有自己完全独立的运行环境，多进程共享数据是一个问题
- 线程：
    - 一个进程独立运行片段，一个进程可以有多个线程
    - 例如运行中的360软件是一个进程，360下面的软件管家、优化加速、木马查杀等是多个线程，这几个线程
    同时运行的时候可以共享电脑中的一些文件。
    - 共享互斥问题
- 全局解释器锁（GIL）
    - python代码的执行是由python虚拟机进行控制
    - 在主循环中只能有一个控制线程在运行（有全局解释锁写死限制如此）
- python包
    - thread：有问题，不常用，在python3中变为 _thread
    - threading：通用的包，现在都用这个了
    - 见01_threading.py
    - 案例01：耗时较长，见02_threading.py
    - 案例02：使用 _thread，缩短时间
    - 案例03：使用参数，见03_threading_加参数
- threading的使用：
    - 直接使用threading.Thread生成Thread实例
    - 1. t = threading.Thread(target = xxx, args = (xxx,)) 一个参数的时候后面加逗号，多个参数不用加
    - 2. t.start()：启动多线程
    - 3. t.join():等待多线程执行完成
    - 见案例04_threading.py
    - 案例05_join加入join后与案例04比较结果
    - 守护线程 daemon
        - 如果在程序中将子线程设置为守护线程，则子线程会在主线程结束的时候自动退出
        - 一般认为，守护线程不重要或者不允许离开主线程独立运行
        - 守护线程案例能否有效果和环境相关
        - 见案例06_守护线程.py
    - 线程常用属性：
        - threading.currentThread：返回当前线程变量
        - threading.enumerate：返回一个包含正在运行线程的list，正在运行的线程指的是线程启动后
        - threading.activeCount：返回正在运行的线程数量，效果和len(threading.enumerate)一样
        - thr.setName：设置线程名称
        - thr.getName：得到线程名称
        - 见案例07_线程属性.py
    - 直接继承threading.Thread
        - 直接继承Thread
        - 重写run函数
        - 类实例可以直接运行
        - 案例08_继承threading.Thread
- 共享变量
    - 共享变量：当多个线程同时访问一个变量的时候，会产生共享变量的问题
    - 见案例09_共享变量.py
    - 锁（lock）、信号灯
        - 是一个标志，表示一个线程在占用一些资源
        - 使用方法：
            - 上锁
            - 使用共享资源，放心使用
            - 取消锁、释放锁
        - 见案例10_lock.py
        - 需要锁的对象：哪个资源需要多个线程共享就锁哪个
        - 理解锁：锁其实是一个标志，就是当前共享资源使用完之后才释放，是一个令牌。
    - 线程安全
        - 如果一个资源/变量，对于多线程来说，不用加锁也不会引发任何问题，则称为线程安全
        - 线程不安全变量类型：list set dict
        - 线程安全的类型：queue
    - 生产者消费者问题（模型）
        - 见案例11_生产者消费者模型.py
        
# 协程
- 参考资料
- 迭代器
    - 可迭代（Iterable）：直接作用于for循环的变量
    - 迭代器：不但可以作用于for循环，还可以被next调用
    - 一个迭代器一定是可迭代对象；可迭代的不一定是迭代器。
    - 通过 isinstance判断一个对象是否是不是一个什么的实例
    - Iterable和Iterator可以转换
        - 通过方法iter()转换
    - 见案例14
## 生成器
- generator：一边循环一边计算下一个元素的机制/算法
- 需要满足三个条件：
    - 每次调用都生产出for循环需要的下一个元素
    - 如果达到最后一个后，会报出StopIteration异常
    - 可以被next调用
- 如何生成一个迭代器
    - 直接使用
    - 如果函数中包含yield，则这个函数就叫生成器
    - next调用函数，遇到yield返回
    - 见案例15
## 协程
- 历史：
    - 3.4引入协程，用yield
- 定义
    - 协程 是为非抢占式多任务子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序
    - 技术角度看，协程就是可以中断执行，去执行其他子程序，然后可以再返回继续执行的一个子程序
    - yield返回
    - send发送
    - 案例16
- 协程的四个状态
    - inspect.getgeneratorstate(......) 函数确定，该函数会返回下属字符串中的一个：
        - GEN_CREATED  等待开始执行
        - GEN_RUNNING  解释器正在执行
        - GEN_SUSPEND: 在yield表达式处暂停
        - GEN_CLOSED： 执行结束
    - next()预激  让协程开始执行
    - 案例17
- 协程终止
    - 协程中未处理的异常会向上冒泡，传给next函数或send方法的调用方（即触发协程的对象）
    - 终止协程的一种方式：发送某个哨符值，让协程退出，内置的None和Ellipsis等常量经常用做哨符值==
- yield from
    - 调用协程为了得到返回值，协程必须正常终止
    - 生成器正常终止会发送StopInteration异常，异常对象的vlaue属性保存返回值
    - yield from 从内部捕获StopInteration异常
    - 案例18


    
    